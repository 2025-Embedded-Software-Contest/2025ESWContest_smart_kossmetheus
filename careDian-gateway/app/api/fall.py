import httpx
import asyncio
from typing import Optional, Dict, Any
from fastapi import APIRouter, HTTPException, Depends
from pydantic import BaseModel, Field
from collections import defaultdict

from app.core.rate_limit import should_alert
from app.core.config import settings  
from app.services import influx_v1 as influx
from app.services.ha_notify import send_fall_alert
from app.services.influx_v1 import InfluxServiceV1
from app.services.fall_runtime import FallRuntime
from app.security.cc_jwt import m2m_required


influx = InfluxServiceV1(
    url=settings.influx_url,
    database=settings.influx_db,
    username=settings.influx_username,
    password=settings.influx_password
)

router = APIRouter(prefix="/events", tags=["fall"])

# Ï∂îÍ∞Ä Î™®Îç∏ Îü∞ÌÉÄÏûÑ Ï¥àÍ∏∞Ìôî & Î≥¥Ï†ï ÌååÎùºÎØ∏ÌÑ∞
runtime = FallRuntime(  # ADDED
    model_path   = getattr(settings, "fall_model_path", "/models/fall_lstm_model_final_v2.keras"),
    scaler_path  = getattr(settings, "fall_scaler_path", "/models/scaler_final_v2.pkl"),
    meta_path    = getattr(settings, "fall_meta_path", None),
    threshold    = getattr(settings, "fall_threshold", None),
    smooth_k     = getattr(settings, "fall_smooth_k", 3),
    backend      = getattr(settings, "fall_backend", "keras"),
)
_ai_over_cnt: Dict[str, int] = defaultdict(int)  
AI_SUSTAIN_K = getattr(settings, "fall_ai_sustain_k", 1)  
COOLDOWN_SEC = getattr(settings, "fall_cooldown_sec", 300)  
INFERENCE_ENABLED = getattr(settings, "fall_inference_enabled", True)  

async def get_notify_device() -> Optional[str]:
    """Home AssistantÏóêÏÑú notify.mobile_app_* ÏÑúÎπÑÏä§ Ï§ë Ï≤´ Î≤àÏß∏Î•º Î∞òÌôò"""
    url = f"{settings.ha_base_url.rstrip('/')}/api/services"
    headers = {"Authorization": f"Bearer {settings.ha_token}"}

    try:
        async with httpx.AsyncClient(timeout=5) as client:
            r = await client.get(url, headers=headers)
            if r.status_code != 200:
                print(f"Failed to fetch notify devices: {r.status_code}")
                return None

            data = r.json()
            notify_services = [s for s in data if s["domain"] == "notify"]
            if not notify_services:
                return None

            for name in notify_services[0]["services"].keys():
                if name.startswith("mobile_app_"):
                    return f"notify.{name}"  
    except Exception as e:
        print(f"Error fetching HA devices: {e}")
        return None

class FallEvent(BaseModel):
    device_id: str = Field(..., description="ESP32 ÎòêÎäî ÏÑºÏÑú ÎîîÎ∞îÏù¥Ïä§ ID")
    presence: int = Field(..., description="ÏÇ¨Îûå Ï°¥Ïû¨ Ïó¨Î∂Ä (0: ÏóÜÏùå, 1: ÏûàÏùå)")
    movement: int = Field(..., description="ÏõÄÏßÅÏûÑ ÏÉÅÌÉú (0: ÏóÜÏùå, 1: Ï†ïÏßÄ, 2: ÌôúÎèô)")
    moving_range: int = Field(..., description="ÏõÄÏßÅÏûÑ Í±∞Î¶¨/Î≤îÏúÑ")
    fall_state: int = Field(..., description="ÎÇôÏÉÅ ÏÉÅÌÉú (0: Ï†ïÏÉÅ, 1: ÎÇôÏÉÅ Í∞êÏßÄ)")
    dwell_state: int = Field(..., description="Ï†ïÏßÄ ÏÉÅÌÉú (0: ÏóÜÏùå, 1: Ïû•ÏãúÍ∞Ñ Ï†ïÏßÄ)")
    ts: int = Field(..., description="ÌÉÄÏûÑÏä§ÌÉ¨ÌîÑ (Ï¥à Îã®ÏúÑ)")
    location: str = Field("Í±∞Ïã§", description="ÏÑºÏÑú ÏúÑÏπò (Í∏∞Î≥∏: Í±∞Ïã§)")
    predicted_prob: Optional[float] = Field(
        None,
        ge=0.0,
        le=1.0,
        description="(ÏÑ†ÌÉù) LSTM ÏòàÏ∏° ÎÇôÏÉÅ ÌôïÎ•†"
    )
    meta: Optional[Dict[str, Any]] = Field(
        default=None,
        description="(ÏÑ†ÌÉù) Ï∂îÍ∞Ä Î©îÌÉÄ Ï†ïÎ≥¥"
    )

async def check_post_fall_motion(ev: FallEvent):
    await asyncio.sleep(15)  # 30Ï¥à ÎåÄÍ∏∞
    try:
        # 30Ï¥à ÌõÑ InfluxÏóêÏÑú ÏµúÍ∑º movement Îç∞Ïù¥ÌÑ∞ Í∞ÄÏ†∏Ïò§Í∏∞
        query = f"""
        from(bucket: "{settings.influx_db}")
          |> range(start: -40s)
          |> filter(fn: (r) => r["_measurement"] == "fall_event")
          |> filter(fn: (r) => r["device_id"] == "{ev.device_id}")
          |> last()
        """
        # Influx v1 ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏Í∞Ä ÏûàÏúºÎ©¥ ÏßÅÏ†ë get_recent_movement Íµ¨ÌòÑÌï¥ÎèÑ OK
        last_data = influx.query_last_movement(ev.device_id) if hasattr(influx, "query_last_movement") else None
        movement_val = None

        if last_data:
            movement_val = last_data.get("movement", None)

        print(f"[CHECK] 30Ï¥à ÌõÑ movement ÏÉÅÌÉú: {movement_val}")

        if movement_val in (0,1) :
            print(f"üö® [ALERT] {ev.device_id} - 30Ï¥àÍ∞Ñ ÏõÄÏßÅÏûÑ ÏóÜÏùå, Ï∂îÍ∞Ä ÏïåÎ¶º Ï†ÑÏÜ°")
            await send_fall_alert(
                device_id=ev.device_id,
                title="‚ö†Ô∏è Ïû•ÏãúÍ∞Ñ ÏõÄÏßÅÏûÑ ÏóÜÏùå",
                message=f"{ev.location}ÏóêÏÑú ÎÇôÏÉÅ ÌõÑ 30Ï¥àÍ∞Ñ ÏõÄÏßÅÏûÑÏù¥ ÏóÜÏäµÎãàÎã§.",
                location=ev.location,
                moving_range=ev.moving_range,
                dwell_state=ev.dwell_state,
                ts=ev.ts,
            )
        else:
            print(f"[INFO] 30Ï¥à ÎÇ¥ ÏõÄÏßÅÏûÑ Í∞êÏßÄÎê® ({movement_val}), Ï∂îÍ∞Ä ÏïåÎ¶º ÏÉùÎûµ")
    except Exception as e:
        print(f"[ERROR] post-fall motion check Ïã§Ìå®: {e}")

async def record_fall_event(ev: FallEvent) -> bool:
    """
    InfluxDBÏóê ÎÇôÏÉÅ Ìè¨Ïù∏Ìä∏ 1Í±¥ Í∏∞Î°ù.
    Ïã§Ìå®Ìï¥ÎèÑ ÏòàÏô∏Îäî Ïò¨Î¶¨ÏßÄ ÏïäÍ≥† False Î∞òÌôò.
    """
    try:
        ts_ns = int(ev.ts) * 1_000_000_000 if getattr(ev, "ts", None) else None
        if getattr(ev, "timestamp_ns", None) is not None:
            ts_ns = int(ev.timestamp_ns)

        # predicted_prob/ prob Ìò∏Ìôò
        prob = float(getattr(ev, "prob", getattr(ev, "predicted_prob", 0.0)))

        ok = influx.write_point(
            measurement=settings.influx_measurement,           
            tags={
                "device_id": ev.device_id,                     
                "location": ev.location or settings.location_default,
            },
            fields={
                "prob": prob,
                "fall_state": int(ev.fall_state),
                "moving_range": int(getattr(ev, "moving_range", 0) or 0),
                "dwell_state": int(getattr(ev, "dwell_state", 0) or 0),
                "presence": int(getattr(ev, "presence", 0) or 0),
                "movement": int(getattr(ev, "movement", 0) or 0),
            },
            ts_ns=ts_ns,                                       # ÏóÜÏúºÎ©¥ ÏÑúÎ≤ÑÏãúÍ∞Ñ ÏÇ¨Ïö©
            rp=getattr(settings, "influx_rp", None),           # Ïòà: autogen
        )
        return bool(ok)
    except Exception:
        # log.exception("Influx write failed for fall_event")
        return False
    
@router.post("/fall")
async def receive_fall(
    ev: FallEvent,
    sub: str = Depends(m2m_required(["events:fall:ingest"])),
    ) -> Dict[str, Any]:
    """
    ÎÇôÏÉÅ Ïù¥Î≤§Ìä∏ ÏàòÏã† Î∞è Ï≤òÎ¶¨
    M2M Ïù∏Ï¶ù ÌïÑÏöî: JWT ÌÜ†ÌÅ∞ with "events:fall:ingest" scope
    """
    print(f"[AUTH] sub={sub}")
    print("[RECEIVED] Fall event data:", ev.dict())

    # (ÏÑºÏÑú ÌåêÎã®Í≥º Î¨¥Í¥ÄÌïòÍ≤å) Î™®Îç∏ Ï∂îÎ°†ÏùÄ Î®ºÏ†Ä ÏàòÌñâÌï¥ ÌôïÎ•† Í∏∞Î°ù
    prob = None
    try:
        if INFERENCE_ENABLED:
            prob, pred = await runtime.update_and_predict(
                device_id=ev.device_id,
                presence=ev.presence,
                movement=ev.movement,
                moving_range=ev.moving_range,
                dwell_state=ev.dwell_state,
            )
            if prob is not None:
                ev.predicted_prob = prob
    except Exception as e:
        print(f"[WARN] model inference failed: {e}")

    success = await record_fall_event(ev)
    
    notify_result = None

    if int(ev.fall_state) == 1 and should_alert(ev.device_id, cooldown_sec=300):
        # ÏïåÎ¶º Î∞úÏÜ° Í∏∞Í∏∞ Î™©Î°ù Ï°∞Ìöå
        ha_device = await get_notify_device()
        if not ha_device:
            print("No HA mobile notify device found")
            raise HTTPException(status_code=500, detail="No HA mobile notify device found")

        print(f"üö® [ALERT] Sending fall alert to {ha_device}")

        # ÎÇôÏÉÅ ÏïåÎ¶º Î∞úÏÜ°
        notify_result = await send_fall_alert(
            device_id=ev.device_id,
            title="üö® ÎÇôÏÉÅ Í∞êÏßÄ",
            message=f"{ev.location or 'home'}ÏóêÏÑú ÎÇôÏÉÅÏù¥ Í∞êÏßÄÎêòÏóàÏäµÎãàÎã§.",
            location=ev.location,
            moving_range=ev.moving_range,
            dwell_state=ev.dwell_state,
            ts=ev.ts,
        )

        # ÎÇôÏÉÅ ÏïåÎ¶º Í≤∞Í≥º Î°úÍπÖ
        print("HA RESPONSE] =>", notify_result)
        try:
            headers = {"Authorization": f"Bearer {settings.ha_token}"}
            async with httpx.AsyncClient() as client:
                r = await client.post(
                    f"{settings.ha_base_url.rstrip('/')}/api/services/input_boolean/turn_on",
                    headers=headers,
                    json={"entity_id": "input_boolean.fall_triggered"}
                )
                print(f"[ENTITY] input_boolean.fall_triggered -> ON (status={r.status_code})")
        except Exception as e:
            print(f"[ENTITY ERROR] failed to update entity: {e}")
            
        # ÎÇôÏÉÅ ÌõÑ ÏùºÏ†ï ÏãúÍ∞Ñ ÏßÄÎÇòÎ©¥ ÌÉúÏä§ÌÅ¨ Ïã§Ìñâ
        asyncio.create_task(check_post_fall_motion(ev))
    else:
        print(f"[INFO] No fall detected (fall_state={ev.fall_state})") 

        # === ADDED: ÏÑºÏÑú ÎØ∏Í≤ÄÏßÄ(0) ‚Üí AI Î≥¥Ï†ï ÏïåÎ¶º Î°úÏßÅ
        try:
            if INFERENCE_ENABLED and prob is not None:
                if prob > runtime.threshold:
                    _ai_over_cnt[ev.device_id] += 1
                else:
                    _ai_over_cnt[ev.device_id] = 0

                if _ai_over_cnt[ev.device_id] >= AI_SUSTAIN_K and should_alert(ev.device_id, cooldown_sec=COOLDOWN_SEC):
                    ha_device = await get_notify_device()
                    if not ha_device:
                        print("No HA mobile notify device found (AI backstop)")
                        raise HTTPException(status_code=500, detail="No HA mobile notify device found")

                    print(f"ü§ñ [AI ALERT] Sending backstop fall alert to {ha_device}")
                    msg_extra = f" (Î™®Îç∏ÌôïÎ•† {prob:.2f})"
                    notify_result = await send_fall_alert(
                        device_id=ev.device_id,
                        title="‚ö†Ô∏èÎÇôÏÉÅ ÏùòÏã¨",
                        message=f"{ev.location or 'home'}ÏóêÏÑú ÎÇôÏÉÅ ÏùòÏã¨Ïù¥ Í∞êÏßÄÎêòÏóàÏäµÎãàÎã§.{msg_extra}",
                        location=ev.location,
                        moving_range=ev.moving_range,
                        dwell_state=ev.dwell_state,
                        ts=ev.ts,
                    )
                    print("[HA RESPONSE] =>", notify_result)

                    # ÌõÑÏÜç ÏõÄÏßÅÏûÑ Ï≤¥ÌÅ¨ÎèÑ ÎèôÏùºÌïòÍ≤å ÏàòÌñâ
                    asyncio.create_task(check_post_fall_motion(ev))
        except Exception as e:
            print(f"[WARN] AI backstop failed: {e}")

    if notify_result:
        if any(code >= 400 for code in notify_result.values() if isinstance(code, int)):
            print("[HA ERROR] Notify failed:", notify_result)
            raise HTTPException(status_code=502, detail=f"HA notify failed: {notify_result}")
        
    return {"ok": True, "fall_state": ev.fall_state, "recorded": success, "predicted_prob": ev.predicted_prob,"notify_result": notify_result}
